Visualization: Creating figures
===============================

The Visualization module provides plotting functionality for creating figures from experiment and analysis results.
This includes `plotter` and `drawer` classes to plot data in :py:class:`CurveAnalysis` and its subclasses.
Plotters define the kind of figures to plot, while drawers are backends that enable them to be visualized. 

How much you will interact directly with the visualization module depends on your use case:

- **Running library experiments as-is:** You won't need to interact with the visualization module.
- **Running library experiments with custom styling for figures**: You will be setting figure options through the plotter.
- **Making plots using a plotting library other than Matplotlib**: You will need to define a custom drawer class.
- **Writing your own analysis class**: You don't need to interact with the visualization module.
  if you want to use the the default plotter and drawer settings, or you can customize them
  your plotter and drawer.

Plotters inherit from :class:`BasePlotter` and define a type of figure that may be generated from
experiment or analysis data. For example, the results from :class:`CurveAnalysis` --- or any other
experiment where results are plotted against a single parameter (i.e., :math:`x`) --- can be plotted
using the :class:`CurvePlotter` class, which plots X-Y-like values.

These plotter classes act as a bridge (from the common bridge pattern in software development) between
analysis classes (or even users) and plotting backends such as Matplotlib. Drawers are the backends, with
a common interface defined in :class:`BaseDrawer`. Though Matplotlib is the only officially supported
plotting backend in Qiskit Experiments through :class:`MplDrawer`, custom drawers can be
implemented by users to use alternative backends. As long as the backend is a subclass of
:class:`BaseDrawer`, and implements all the necessary functionality, all plotters should be able to
generate figures with the alternative backend.


Generating and customizing a figure using a plotter
---------------------------------------------------

First, we display the default figure from a :class:`Rabi` experiment as a starting point:

.. jupyter-execute::

    import numpy as np

    from qiskit import pulse
    from qiskit.circuit import Parameter

    from qiskit_experiments.test.pulse_backend import SingleTransmonTestBackend
    from qiskit_experiments.data_processing import DataProcessor, nodes
    from qiskit_experiments.library import Rabi

    with pulse.build() as sched:
        pulse.play(
            pulse.Gaussian(160, Parameter("amp"), sigma=40),
            pulse.DriveChannel(0)
        )

    backend = SingleTransmonTestBackend()

    rabi = Rabi(
        qubit=0,
        backend=backend,
        schedule=sched,
        amplitudes=np.linspace(-0.1, 0.1, 21)
    )

    rabi_data = rabi.run().block_for_results()
    rabi_data.figure(0)

This is the default figure generated by :class:`OscillationAnalysis`, the data analysis
class for the Rabi experiment. The fitted cosine is shown as a blue line, with the 
individual measurements from the experiment shown as data points with error bars corresponding
to their uncertainties. We are also given a small fit report in the caption showing the 
``rabi_rate``.

The plotter that generated the figure can be accessed through the analysis instance,
and customizing the figure can be done by setting the plotter's options. We now modify
the color, symbols, and size of our plot, as well as change the axis labels for the amplitude units:

.. jupyter-execute::
    :hide-code:
    :hide-output:

    %matplotlib inline

.. jupyter-execute::

    # Retrieve the plotter from the analysis instance
    plotter = rabi.analysis.plotter

    # Change the x-axis unit values
    plotter.set_figure_options(
        xval_unit="arb.",
        xval_unit_scale=False   # Don't scale the unit with SI prefixes
    )

    # Change the color and symbol for the cosine
    plotter.figure_options.series_params.update(
        {"cos": {"symbol": "x", "color": "r"}}
    )

    # Set figsize directly so we don't overwrite the entire style
    plotter.options.style["figsize"] = (6,4)

    # Generate the new figure
    plotter.figure()

Plotters have two sets of options that customize their behavior and figure content: 
``options``, which have class-specific parameters that define how an instance behaves,
and ``figure_options``, which have figure-specific parameters that control aspects of the
figure itself, such as axis labels and series colors.

Here is a more complicated experiment in which we customize the figure of a DRAG
experiment before it's run, so that we don't need to regenerate the figure like in 
the previous example:

.. jupyter-execute::

    from qiskit_experiments.library import RoughDrag
    from qiskit_experiments.visualization import PlotStyle

    beta = Parameter("beta")
    with pulse.build(name="xp") as xp:
        pulse.play(pulse.Drag(64, 0.66, 16, beta), pulse.DriveChannel(0))

    drag = RoughDrag(0, xp, backend=backend)

    # Set plotter options
    plotter = drag.analysis.plotter

    # Update series parameters
    plotter.figure_options.series_params.update(
        {
            "nrep=1": {
                "color": (27 / 255, 158 / 255, 119 / 255),
                "symbol": "^",
            },
            "nrep=3": {
                "color": (217 / 255, 95 / 255, 2 / 255),
                "symbol": "s",
            },
            "nrep=5": {
                "color": (117 / 255, 112 / 255, 179 / 255),
                "symbol": "o",
            },
        }
    )

    # Set figure options
    plotter.set_figure_options(
        xval_unit="arb.",
        xval_unit_scale=False,
        figure_title="Rough DRAG Experiment on Qubit 0",
    )
    # Set style parameters
    plotter.options.style["symbol_size"] = 10
    plotter.options.style["legend_loc"] = "upper center"

    drag_data = drag.run().block_for_results()

    drag_data.figure(0)

As can be seen in the figure, the different series generated by the experiment
were styled differently according to the ``series_params`` attribute of ``figure_options``.


Customizing plotting in your experiment
---------------------------------------

Plotters are easily integrated into custom analysis classes. To add a plotter instance
to such a class, we define a new ``plotter`` property, pass it relevant data in the 
analysis class's ``_run_analysis`` method, and return the generated figure alongside our
analysis results. We use the ``IQPlotter`` class to illustrate how this is done for an arbitrary analysis class.

To ensure that we have an interface simlar to existing analysis classes, we make our plotter
accessible as an ``analysis.plotter`` property and analysis.options.plotter option. 
The code below accomplishes this for our example ``MyIQAnalysis`` analysis class. We 
set the drawer to MplDrawer to use Matplotlib by default. The plotter property of our 
analysis class makes it easier to access the plotter instance; i.e., using ``self.plotter``
 and ``analysis.plotter``. We set default options and figure options in 
 ``_default_options``, but you can still override them as we did above.

The ``MyIQAnalysis`` class accepts single-shot level 1 IQ data, which consists of an 
in-phase and quadrature measurement for each shot and circuit. ``_run_analysis`` is 
passed an ``ExperimentData`` instance which contains IQ data as a list of dictionaries 
(one per circuit) where their "memory" entries are lists of IQ values (one per shot). 
Each dictionary has a "metadata" entry, with the name of a prepared state: "0", "1", 
or "2". These are our series names.

Our goal is to create a figure that displays the single-shot IQ values of each 
prepared-state (one per circuit). We process the "memory" data passed to the 
analysis class and set the points and centroid series data in the plotter. 
This is accomplished in the code below, where we also train a discriminator 
to label the IQ points as one of the three prepared states. IQPlotter supports 
plotting a discriminator as optional supplementary data, which will show predicted 
series over the axis area.

.. jupyter-execute::

    from qiskit_experiments.framework import BaseAnalysis, Options
    from qiskit_experiments.visualization import (
        BasePlotter,
        IQPlotter,
        MplDrawer,
        PlotStyle,
    )

    class MYIQAnalysis(BaseAnalysis):
        @classmethod
        def _default_options(cls) -> Options:
            options = super()._default_options()
            # We create the plotter and create an option for it.
            options.plotter = IQPlotter(MplDrawer())
            options.plotter.set_figure_options(
                xlabel="In-phase",
                ylabel="Quadrature",
                figure_title="My IQ Analysis Figure",
                series_params={
                    "0": {"label": "|0>"},
                    "1": {"label": "|1>"},
                    "2": {"label": "|2>"},
                },
            )
            return options

    @property
    def plotter(self) -> BasePlotter:
        return self.options.plotter

    def _run_analysis(self, experiment_data):
        data = experiment_data.data()
        analysis_results = []
        for datum in data:
                # Analysis code
                analysis_results.append(self._analysis_result(datum))

                # Plotting code
                series_name = datum["metadata"]["name"]
                points = datum["memory"]
                centroid = np.mean(points, axis=0)
                self.plotter.set_series_data(
                    series_name,
                    points=points,
                    centroid=centroid,
                )

        # Add discriminator to IQPlotter
        discriminator = self._train_discriminator(data)
        self.plotter.set_supplementary_data(discriminator=discriminator)

        return analysis_results, [self.plotter.figure()]

If we run the above analysis on some appropriate experiment data, as previously 
described, our class will generate a figure showing IQ points and their centroids.

Creating your own plotter
-------------------------

You can create a custom figure plotter by subclassing ``BasePlotter`` and overriding
``expected_series_data_keys``, ``expected_supplementary_data_keys``, and ``_plot_figure``.

The first two methods allow you to define a list of supported data-keys, 
as strings, which identify the different data to plot. The third method, 
``_plot_figure``, must contain your code to generate a figure by calling methods 
on the plotter's drawer instance (self.drawer). When ``plotter.figure()`` is called 
by an analysis class, the plotter calls _plot_figure and then returns your figure 
object which is added to the experiment data instance. It is also good practice to 
set default values for figure options, such as axis labels. You can do this by 
overriding the ``_default_figure_options`` method in your plotter subclass.

See also
--------

API documentation: :doc:`qiskit_experiments.visualization`